-- FreeFem++ v4.400002 (Mon Nov 25 11:54:36 CET 2019 - git no git)
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue 
    1 : load "msh3"  // Generating mesh tool
    2 : load "medit" // Mesh plotting tool
    3 : load "iovtk" load: iovtk 

    4 : 
    5 : include "getARGV.idp" // for gestion of FreeFem++ argument and in version 3.10-1 FH
    2 :  // F. Hecht 
    3 :  // Usage:  getARGV(n,defaultvalue) // get the fist used default valeu
    4 :  //  or     getARGV(after,defaultvalue) // get the arg after after 
    5 :  // the type of delfaut value given the return type: int,double, string
    6 :  // Modif version 3.54-2  Jan 2018 (add ones include)
    7 :  IFMACRO(!getARGVidp)
    8 &  macro getARGVidp 1 //
    9 &  
   10 &  
   11 &  func int usedARGV(int n)
   12 & {
   13 &   int k=1,ii=1,kk=1,ret=-1;
   14 &   for(int i=1;i<ARGV.n;++i)
   15 &    {
   16 &    // cout <<i<< " "<< ARGV[i] << " " <<(ARGV[i]=="-v") << " " << kk << "==" 
   17 &    //      << n << " " << ARGV[i].rfind("dp") << " " <<ARGV[i].length-2  << endl;
   18 &         
   19 &        if(ARGV[i]=="-v") i++;
   20 &        else if(ARGV[i]=="-fglut") i++;
   21 &        else if(ARGV[i]=="-ffg") i++;
   22 &        else if(ARGV[i]=="-glut") i++;
   23 &        else if(ARGV[i]=="-f") i++;
   24 &        else if(ARGV[i]=="-nw") ii;
   25 &        else if(ARGV[i]=="-wait") ii;
   26 &        else if(ARGV[i]=="-ne") ii;
   27 &        else if(ARGV[i]=="-cd") ii;
   28 &        //else if(ARGV[i].rfind(".edp")==ARGV[i].length-4 ) ii;
   29 &        else if(i==1) ii;
   30 &        else if(kk++==n) {ret=i;}
   31 &       // else cout << " +++ \n";
   32 &      }
   33 &    //  cout << ret << endl;
   34 &     return ret;
   35 & }
   36 & 
   37 & func int usedARGV(string after)
   38 & {
   39 &   int ret=-1;
   40 &   for(int i=ARGV.n-1;i>=0;--i)        
   41 &        if(ARGV[i]==after) { ret=++i; break;}
   42 &   if(ARGV.n<ret) ret=-1;
   43 &   return ret;
   44 & }
   45 & 
   46 & func int getARGV(int n,int default)
   47 & {
   48 &    int d=default;
   49 &    int k=usedARGV(n);
   50 &    if(k>0) d=strtol(ARGV[k]);
   51 &     return d;
   52 & }
   53 & func real getARGV(int n,real default)
   54 & {
   55 &    real d=default;
   56 &    int k=usedARGV(n);
   57 &    if(k>0) d=strtod(ARGV[k]);
   58 &    return d;
   59 & }
   60 & func string getARGV(int n,string default)
   61 & {
   62 &    string d=default;
   63 &    int k=usedARGV(n);
   64 &    if(k>0) d=ARGV[k];
   65 &     return d;
   66 & }
   67 & 
   68 & func int getARGV(string after,int default)
   69 & {
   70 &    int d=default;
   71 &    int k=usedARGV(after);
   72 &    if(k>0) d=strtol(ARGV[k]);
   73 &     return d;
   74 & }
   75 & func real getARGV(string after,real default)
   76 & {
   77 &    real d=default;
   78 &    int k=usedARGV(after);
   79 &    if(k>0) d=strtod(ARGV[k]);
   80 &    return d;
   81 & }
   82 & func string getARGV(string after,string default)
   83 & {
   84 &    string d=default;
   85 &    int k=usedARGV(after);
   86 &    if(k>0) d=ARGV[k];
   87 &     return d;
   88 & }
   89 & 
   90 & /*
   91 & cout << getARGV(1,100) << endl;
   92 & cout << getARGV(2,200.) << endl;
   93 & cout << getARGV(3,"300.000") << endl;
   94 & cout << getARGV("-n"," xxx") << endl;
   95 & */
   96 & ENDIFMACRO
    8 :  macro getARGVidp 1 1 //
    9 :  
   10 :  
   11 :  func int usedARGV(int n)
   12 : {
   13 :   int k=1,ii=1,kk=1,ret=-1;
   14 :   for(int i=1;i<ARGV.n;++i)
   15 :    {
   16 :    // cout <<i<< " "<< ARGV[i] << " " <<(ARGV[i]=="-v") << " " << kk << "==" 
   17 :    //      << n << " " << ARGV[i].rfind("dp") << " " <<ARGV[i].length-2  << endl;
   18 :         
   19 :        if(ARGV[i]=="-v") i++;
   20 :        else if(ARGV[i]=="-fglut") i++;
   21 :        else if(ARGV[i]=="-ffg") i++;
   22 :        else if(ARGV[i]=="-glut") i++;
   23 :        else if(ARGV[i]=="-f") i++;
   24 :        else if(ARGV[i]=="-nw") ii;
   25 :        else if(ARGV[i]=="-wait") ii;
   26 :        else if(ARGV[i]=="-ne") ii;
   27 :        else if(ARGV[i]=="-cd") ii;
   28 :        //else if(ARGV[i].rfind(".edp")==ARGV[i].length-4 ) ii;
   29 :        else if(i==1) ii;
   30 :        else if(kk++==n) {ret=i;}
   31 :       // else cout << " +++ \n";
   32 :      }
   33 :    //  cout << ret << endl;
   34 :     return ret;
   35 : }
   36 : 
   37 : func int usedARGV(string after)
   38 : {
   39 :   int ret=-1;
   40 :   for(int i=ARGV.n-1;i>=0;--i)        
   41 :        if(ARGV[i]==after) { ret=++i; break;}
   42 :   if(ARGV.n<ret) ret=-1;
   43 :   return ret;
   44 : }
   45 : 
   46 : func int getARGV(int n,int default)
   47 : {
   48 :    int d=default;
   49 :    int k=usedARGV(n);
   50 :    if(k>0) d=strtol(ARGV[k]);
   51 :     return d;
   52 : }
   53 : func real getARGV(int n,real default)
   54 : {
   55 :    real d=default;
   56 :    int k=usedARGV(n);
   57 :    if(k>0) d=strtod(ARGV[k]);
   58 :    return d;
   59 : }
   60 : func string getARGV(int n,string default)
   61 : {
   62 :    string d=default;
   63 :    int k=usedARGV(n);
   64 :    if(k>0) d=ARGV[k];
   65 :     return d;
   66 : }
   67 : 
   68 : func int getARGV(string after,int default)
   69 : {
   70 :    int d=default;
   71 :    int k=usedARGV(after);
   72 :    if(k>0) d=strtol(ARGV[k]);
   73 :     return d;
   74 : }
   75 : func real getARGV(string after,real default)
   76 : {
   77 :    real d=default;
   78 :    int k=usedARGV(after);
   79 :    if(k>0) d=strtod(ARGV[k]);
   80 :    return d;
   81 : }
   82 : func string getARGV(string after,string default)
   83 : {
   84 :    string d=default;
   85 :    int k=usedARGV(after);
   86 :    if(k>0) d=ARGV[k];
   87 :     return d;
   88 : }
   89 : 
   90 : /*
   91 : cout << getARGV(1,100) << endl;
   92 : cout << getARGV(2,200.) << endl;
   93 : cout << getARGV(3,"300.000") << endl;
   94 : cout << getARGV("-n"," xxx") << endl;
   95 : */
   96 : 
    6 : include "data.edp"// GENERAL DATA:
    2 : real Cp = 1012.;                // Specific heat capacity of air
    3 : real lambda = 0.024;            // Thermal conductivity of the air
    4 : real Ilight = 45.;              // Light intensity (in W/m^2) -> given
    5 : real g = 9.81;                  // Gravitational acceleration
    6 : real rhoa = 1.29;               // Density of the air (kg/m^3) taken from internet
    7 : 
    8 : real Sh2o=0.;                   // Source term for H2O concentration balance
    9 : real Sco2=0.;                   // Source term for CO2 concentration balance
   10 : // Source terms Sh20, Sco2 are updated at each iteration from Van Henten (from fphot)
   11 : 
   12 : real lambdaE = 0.;              // Latent heat exchange
   13 : real LAI = 0.;                  // Leaf Area Index
   14 : real Rnet = 0.;                 // Net radiation, amount of radiation intercepted and absorbed by the crop
   15 : real H = 0.;                    // Sensible heat exchange
   16 : 
   17 : real Ta = 0.;                   // Temperature of air
   18 : real Tc = 0.;                   // Temperature of Canopy (= Ta - 1)
   19 : // Tc=21.2 during the day e Tc=20.8 during the night (it should be a consequence of turning on/off LED lights)
   20 : 
   21 : real gammaCO2 = 0.;             // CO2 concentration in air
   22 : real gammaH2Oair = 0.;          // Vapour concentration in air
   23 : real gammaH2Osur = 0.;          // Vapour concentration on canopy surface
   24 : 
   25 : // Number of iterations in time
   26 : int t0 = 0;
   27 : int tmax = 86400*20;    // seconds in 20 days
   28 : int dt = 24*60*60;
   29 : int N=(tmax - t0)/dt;
 *** Warning  The identifier N hide a Global identifier  

   30 : 
   31 : 
   32 : // NARANJANI:
   33 : real L = 1;             // Characteristic length of the cell (m)
   34 : real mu = 1e-5;           // Air viscosity
   35 : real U = 0.3;           // Characteristic velocity and inlet boundary velocity (Dirichlet condition NS)
   36 : real Tamb = 25;         // Ambient Temperature (Celsius): boundary cond. in cell energy balance
   37 : 
   38 : 
   39 : // VAN HENTEN:
   40 : //Constants for the dfferential equations
   41 : real calpha   = 0.68;            // Ratio of molecular weight of CH20 and CO2
   42 : real cbeta    = 0.8;             // Respiratory and synthesis losses of non-structural material due to growht
   43 : 
   44 : //Constants for r_gr equation
   45 : real cgrMax   = 5e-6;            // Saturation growth rate at 20°C (s^-1)
   46 : real cgamma   = 1;               // Should have a value between 0.5-1.0
   47 : real cQ10gr   = 1.6;             // Q10 factor for growth
   48 : 
   49 : //Constants for f_resp equation
   50 : real ctau     = 0.15;            // Ratio of the root dry weight and the total dry weight
   51 : real crespSHT = 3.47e-7;         // Shoot maintenance respiration coefficient at 25°C (s^-1)
   52 : real crespRT  = 1.16e-7;         // Root maintenance respiration coefficient at 25°C (s^-1)
   53 : real cQ10resp = 2;               // Q10 factor of the maintenance respiration
   54 : 
   55 : //Constants for f_phot equation
   56 : real ck        = 0.9;            // Extinction coefficient
   57 : real clar      = 75e-3;          // Structural leaf area (m^2 * g)
   58 : real comega    = 1.83e-3;        // Estimated CO2 density at 15◦C temperature and ambient pressure (g * m^-3)
   59 : real cGamma    = 40;             // CO2 compensation point at 20°C (ppm)
   60 : real cQ10gamma = 2;              // Q10 value which accounts for the effect of temperature on Γ
   61 : real cepsilon  = 17e-6;          // Value of epsilon at very high CO2 concentration (g * J^-1)
   62 : real gbnd      = 7e-3;           // Boundary layer conductance (m * s^-1) (wind 0.1ms^-1, deltaT=5, char length = 0.075m)
   63 : real gstm      = 5e-3;           // Stomatal conductance (m * s^-1) (for a crop not subjected to stress)
   64 : real ccar1     = -1.32e-5;       // (m * s^-1 * °C^-2)
   65 : real ccar2     = 5.94e-4;        // (m * s^-1 * °C^-1)
   66 : real ccar3     = -2.64e-3;       // (m * s^-1)
   67 : 
   68 : // Stopping criteria for fixed point method
   69 : real Nmax = 100;
   70 : real toll2 = 1e-3;
   71 : 
   72 : // Initial dry weigth values (provided by Agricola Moderna)
   73 : real Xnsdw = 6.75e-5;
   74 : real Xsdw = 2.25e-5;
   75 : 
   76 : // Vectors for dry weight data storage in time:
   77 : int[int] Time(N+1);
   78 : real[int, int] vectDW(2,N+1);
   79 : vectDW(:,0) = [Xnsdw, Xsdw];
   80 : 
   81 : // Vectors for temperature data storage in time:
   82 : real[int] vectTa(N+1);
   83 : real[int] vectTc(N+1);
   84 : vectTa(0) = Ta;
   85 : vectTc(0) = Tc;
   86 : 
   87 : 
   88 : // GRAAMANS:
   89 : real rhor = 0.05;      // Reflection coefficient
   90 : real CAC = 0.9;        // Cultivation area cover
   91 : // CAC is % of projected leaf area to cultivation area
   92 : 
   93 : real PPFD = 4.6 * Ilight;      // Photosynthetic photon flux densities (micromol / m^2 s)
   94 : // Coefficient 4.6 considers the complete light spectrum
   95 : real l = 0.11;                 // Mean leaf diameter
   96 : 
    7 : 
    8 : int meshSize = getARGV("-n", 10);
    9 : 
   10 : //Mesh Generation
   11 : mesh3 Th = cube(meshSize, meshSize, meshSize, [L*x,L*y,L*z]);
   12 : 
   13 : func real chi() {
   14 :     if(x>=0.475 && x<=0.525 && y>=0.475 && y<=0.525 && z>=0 && z<=0.15)
   15 :         return 1;
   16 :     else
   17 :         return 0;
   18 : }
   19 : 
   20 : //Fespace
   21 : fespace Vh(Th, [P2, P2, P2]);
   22 : Vh [ux, uy, uz];
   23 : Vh [upx, upy, upz];
   24 : Vh [vx, vy, vz];
   25 : Vh [dux, duy, duz];
   26 : 
   27 : fespace Qh(Th, P1);
   28 : Qh p;
   29 : Qh q;
   30 : 
   31 : //Macro
   32 : macro grad(u) [dx(u), dy(u), dz(u)]  )   [dx(u), dy(u), dz(u)] //
   33 : macro Grad(U) [grad(U#x), grad(U#y), grad(U#z)] )   [grad(U#x), grad(U#y), grad(U#z)]//
   34 : macro div(ux, uy, uz) (dx(ux) + dy(uy) + dz(uz))  )   (dx(ux) + dy(uy) + dz(uz)) //
   35 : macro Div(U) div(U#x, U#y, U#z)  )   div(U#x, U#y, U#z) //
   36 : 
   37 : //Function
   38 : func uIn = U;
   39 : real Re = rhoa*U*L / mu; //Reynolds number
   40 : cout << "Re: " << Re << endl;
   41 : real dt1 = 1.e-2;
   42 : 
   43 : //Problem
   44 : problem NS ([ux, uy, uz, p],[vx, vy, vz, q])
   45 : 	= int3d(Th)(
   46 : 		  (1/dt1) * [ux, uy, uz]' * [vx, vy, vz]
   47 : 		+ 1/Re * (Grad(u)    [grad(ux)     [dx(ux), dy(ux), dz(ux)] , grad(uy)     [dx(uy), dy(uy), dz(uy)] , grad(uz)     [dx(uz), dy(uz), dz(uz)] ] : Grad(v)    [grad(vx)     [dx(vx), dy(vx), dz(vx)] , grad(vy)     [dx(vy), dy(vy), dz(vy)] , grad(vz)     [dx(vz), dy(vz), dz(vz)] ])
   48 : 		- p * Div(v)     div(vx, vy, vz)       (dx(vx) + dy( vy) + dz( vz))  
   49 : 		- Div(u)     div(ux, uy, uz)       (dx(ux) + dy( uy) + dz( uz))   * q
   50 : 	)
   51 : 	- int3d(Th)(
   52 : 		  (1/dt1) * [convect([upx, upy, upz], -dt, upx), convect([upx, upy, upz], -dt, upy), convect([upx, upy, upz], -dt, upz)]' * [vx, vy, vz]
   53 : 		- g * vz
   54 : 	)
   55 : 	+ on(1, ux=uIn, uy=0., uz=0.)
   56 : 	+ on(2,4,5,6, ux=0., uy=0., uz=0.);
   57 : 
   58 : // Time loop
   59 : // int nbiter = T / dt1;
   60 : real tol = 1e-6;
   61 : real err = tol + 1;
   62 : while (err > tol) {
   63 : 	// Update
   64 : 	[upx, upy, upz] = [ux, uy, uz];
   65 : 
   66 : 	// Solve
   67 : 	NS;
   68 : 
   69 : 	dux[] = ux[] - upx[];
   70 : 	duy[] = uy[] - upy[];
   71 : 	duz[] = uz[] - upz[];
   72 : 	err = sqrt(int3d(Th)(grad(dux)     [dx(dux), dy(dux), dz(dux)] '*grad(dux)     [dx(dux), dy(dux), dz(dux)]  + grad(duy)     [dx(duy), dy(duy), dz(duy)] '*grad(duy)     [dx(duy), dy(duy), dz(duy)]  + grad(duz)     [dx(duz), dy(duz), dz(duz)] '*grad(duz)     [dx(duz), dy(duz), dz(duz)] ))/dt1;
   73 : }
   74 : 
   75 : plot([ux, uy, uz], cmm="Velocity"); sizestack + 1024 =3904  ( 2880 )

  Enter: BuildCube: 6
    kind = 6 n tet Cube = 6 / n slip 6 70
  Cube  nv=17576 nt=93750 nbe=7500
  Out:  BuildCube
  -- Build Nodes/DF on mesh :   n.v. 17576, n. elmt. 93750, n b. elmt. 7500
     nb of Nodes 132651    nb of DoF   397953  DFon=3300
  -- FESpace: Nb of Nodes 132651 Nb of DoF 397953
  -- FESpace: Nb of Nodes 17576 Nb of DoF 17576
Re: 38700
  -- Build Nodes/DF on mesh :   n.v. 17576, n. elmt. 93750, n b. elmt. 7500
     nb of Nodes 132651    nb of DoF   415529  DFon=4300
 Error umpfack umfpack_di_numeric  status  -1
 Error umfpack_di_solve  status  -3
  -- Solve : 
          min 0  max 0.3
          min 0  max 0
 Error umpfack umfpack_di_numeric  status  -1
 Error umfpack_di_solve  status  -3
  -- Solve : 
          min 0  max 0.3
          min 0  max 0
  Plot::  Sorry no ps version for this type of plot 7
times: compile 0.278969s, execution 182.989s,  mpirank:0
 ######## We forget of deleting   2 Nb pointer,   0Bytes  ,  mpirank 0, memory leak =32
 CodeAlloc : nb ptr  4060,  size :464536 mpirank: 0
Ok: Normal End
