// parameters for the energy balance equation for a transpiring plant surface
real Rnet = 0.;        // net radiation, amount of radiation intercepted and absorbed by the crop
real H = 0.;            // sensible heat exchange

// R_net equation
real rhor = 0.05;      // reflection coefficient
real CAC = 0.9;         // cultivation area cover
real Ilight = 45;      // radiation effectively absorbed by the crop

Rnet = (1 - rhor) * Ilight * CAC;
cout << "R_net = " << Rnet << endl;

// H equation
real PPFD = 600;                                   // photosynthetic photon flux densities
real l = 0.11;                                     // mean leaf diameter
real uinf = 50;                                    // uninhibited air speed (trovato dove?)

real LAI = (1-ctau)*clar*Xsdw/1;                   // leaf area index, in Graamans is 3, we use the value obtained in VanHenten
//diviso il numero di piante per unitÃ  di superficie
real ra = 305 * (l / uinf)^(1/2) / LAI;            // aerodynamic resistance to heat
real rs = 60 * (1500 + PPFD) / (200 + PPFD);       // surface resistance
real Cp=1012;                                      //specific heat capacity of air 
real lambda=0.024;                                  //thermal conductivity of the air

H = LAI * rhoa * Cp / ra;
cout << "H = " << H << endl;


// lambda_E equation (the data are random)
real eps = 0.5;             // vapour concentration
real lambdaH = 0.;               // latent heat of the evaporation of water
//real gammaH2Oair = 0.17;        // vapour concentration in the surrounding air
//real gammaH2Osur = 0.23;        // vapour concentration at the transpiring surface

// this two values are obtained by the species mass fraction transport equation of Naranjani
// Penman and Monteith give us the following relation between the two

real gammaH2Osur = gammaH2Oair + rhoa * Cp * eps * (Tc - Ta);


// our goal is to find lambda hence we can compute it by using R_net - H = lambda_e
lambdaH = (ra + rs) * (Rnet - H) / (LAI * (gammaH2Osur - gammaH2Oair));
cout << "lambdaH = " << lambdaH << endl;

lambdaE = LAI * lambdaH * (gammaH2Osur - gammaH2Oair) / (ra + rs);
cout << "lambdaE = " << lambdaE << endl;