real Sh2o=0, Sco2=0; //valore iniziale, poi da modificare con la retroazione

real lambdaE = 0.;     // latent heat exchange
real LAI = 0.;   // Leaf Area Index

include "VanHenten_data.edp"

// dal Naranjani prendiamo la canopy temperature T
//Tc=21.2 di giorno e Tc=20.8 di notte (dovrebbero essere conseguenza dell'accensione/spegnimento dei led)
//sempre dal naranjani prendiamo h20 e co2
include "Naranjani_newton.edp"

real Ta=21; //valore prova di inizializzazione 
real Tc=Ta-1;
real gammaCO2=800; //valore prova di inizializzazione (internet) in ppm
real gammaH2Oair = 0.01667; //valore prova (internet) in g/m^3
real gammaH20sur = gammaH20air //@ tempo 0 non c'è differenza tra aria e superficie pianta

// N si trova in Van Henten data, cambia x aumentare iterazioni per introdurre giorno/notte !!!!!

for (int t = 0; t < N; t++){

    cout << "giorno: " << t+1 << endl;

    real night=0; //dobbiamo capire come gestire notte e giorno

    include "VanHenten.edp"

    // Convertiamo u.m. dei valori da inserire su Naranjani
    real fph=fphot(Xsdw);
    cout << "fphot = " << fph << endl;
    // fph è g/m^(2)
    Sco2=fph/1000; //da g a kg
    Sh2o=fph/1000;
    //dobbiamo arrivare ad avere kg/m^3
    //prendiamo come lunghezza caratteristica l'altezza della pianta (cfr. Naranjani)
    //conversione 1 a 1, dividiamo per 1m

    //ofstream file("result.txt");
    //file << "X_nsdw = " << Xnsdw << "\n";
    //file << "X_sdw = " << Xsdw << "\n";

    //Compute LAI from Xsdw using formula provided by Van Henten:
    LAI = (1-ctau)*clar*Xsdw;

    include "Graamans.edp"

    //Value of lambdaE is computed within Graamans --> lambdaE = Rnet - H;
    include "Naranjani_energy.edp"

    //Come nuovo valore di Ta prendiamo la media integrale di T calcolata da Naranjani:
    Ta = int3d(Th)(T)/int3d(Th)(1.0);
    Tc= Ta-1; //approssimazione data da Alessandro
    cout << "Tc = " << Tc << endl;

    gammaCO2 = int3d(Th)(co2*1e6)/int3d(Th)(1.0);
    cout << "gammaCO2 = " << gammaCO2 << endl;
    gammaH2Oair = int3d(Th)(h2o * rhoa * 1e+3)/int3d(Th)(1); //integral mean and change of unit (now we want it g/m^3)
    // gammaH20sur = ... SERVE IN GRAAMANS!!

    cout << "\n" << endl;
}

//plot([Time,vectNSDW], wait=true);
/* ofstream gnu("plotNSDW.gp");
for (int i = 0; i < N; i++)
        gnu << Time[i] << " " << vectNSDW[i] << endl;

//exec("echo 'plot \"plotNSDW.gp\" w l \n pause 5 \n set term postscript \n set output \"gnuplot.eps\" \n replot \n quit' | gnuplot");

ofstream gnu("plot.gp");
for (int i = 0; i < N; i++)
    gnu << Time[i] << " " << vectSDW[i] << endl;

//exec("echo 'plot \"plotSDW.gp\" w l \n pause 5 \n set term postscript \n set output \"gnuplot.eps\" \n replot \n quit' | gnuplot");
*/

//plot([Time,vectSDW], ps="SDWplot.eps");