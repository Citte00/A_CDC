load "msh3"

//data
real Mu=1.825*10^(-5); //a 20C da internet
real rhoa=1.293; // da internet
real g=9.81; //gravitational acceleration
real uMax = 10.;

//mesh generation
real L = 1.;
mesh3 Th = cube(20, 20, 20, [L*x, L*y, L*z]);

fespace Uh(Th, [P23d, P23d, P23d]);
Uh [ux, uy, uz], [vx, vy, vz], [ux1, uy1, uz1], [dux, duy, duz];

fespace Ph(Th, P13d);
Ph p, q, dp;

//Macro
macro Gradient(u) [dx(u), dy(u), dz(u)] //
macro Divergence(ux, uy, uz) (dx(ux) + dy(uy) + dz(uz)) //
macro UgradV(ux,uy,uz,vx,vy,vz) [ [ux,uy,uz]'*[dx(vx),dy(vx),dz(vx)] , [ux,uy,uz]'*[dx(vy),dy(vy),dz(vy)], [ux,uy,uz]'*[dx(vz),dy(vz),dz(vz)]]// EOM

real arrns = 1e-9;

macro ns() {
 int n;
 real err=0;
 S;
/* Newton Loop  */
 for(n=0; n< 15; n++) {
   LinNS;
   dux[] = ux1[] - ux[];
   duy[] = uy1[] - uy[];
   duz[] = uz1[] - uz[];
   err = sqrt(int2d(Th)(Gradient(dux)'*Gradient(dux) + Gradient(duy)'*Gradient(duy) + Gradient(duz)'*Gradient(duz))) /
     sqrt(int2d(Th)(Gradient(ux)'*Gradient(ux) + Gradient(uy)'*Gradient(uy) + Gradient(uz)'*Gradient(uz)));
   ux[] = ux1[];
   uy[] = uy1[];
   uz[] = uz1[];
   cout << err << " / " << arrns << endl;
   cout.flush;
   if(err < arrns) break;
 }
 /* Newton loop has not converged */
 if(err > arrns) {
   cout << "NS Warning : non convergence : err = " << err << " / eps = " << arrns << endl;
 }

} //EOF

//Function
func uIn = uMax * (1.-(y-L/2.)^2/(L/2.)^2);

//Problem
problem S ([ux, uy, uz, p],[vx, vy, vz, q])
	= int2d(Th)(Mu * (Gradient(ux)' * Gradient(vx) + Gradient(uy)' * Gradient(vy) + Gradient(uz)' * Gradient(vz))
	- p * Divergence(vx, vy, vz) - Divergence(ux, uy, uz) * q)
	+ on(1, ux=uIn, uy=0., uz=0.)
	+ on(2,3,4,5,6, ux=0., uy=0., uz=0.);

problem LinNS([ux1,uy1,uz1,dp],[vx,vy,vz,q]) =
     int2d(Th)(Mu*(Gradient(ux1)'*Gradient(vx) + Gradient(uy1)'*Gradient(vy) + Gradient(uz1)'*Gradient(vz))
	       + UgradV(ux1,uy1,uz1,ux,uy,uz)'*[vx,vy,vz] + UgradV(ux,uy,uz,ux1,uy1,uz1)'*[vx,vy,vz]
	       - Divergence(ux1,uy1,uz1)*q - Divergence(vx,vy,vz)*dp)
     -int2d(Th)(UgradV(ux,uy,uz,ux,uy,uz)'*[vx,vy,vz])
     +on(1, ux1=uIn, uy1=0., uz1=0.)
     +on(2,3,4,5,6, ux1=0., uy1=0., uz1=0.);

ns;
//Plot
plot(p , ps="pressure.ps", value=1, fill=1);
plot([ux, uy, uz], ps="velocity.ps", value=1, coef=.05);